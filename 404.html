<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        #scene-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: black;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js",
                "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/loaders/GLTFLoader.js",
                "FontLoader": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/loaders/FontLoader.js",
                "TextGeometry": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/geometries/TextGeometry.js"
            }
        }
        </script>
</head>

<body>
    <div id="scene-container"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        import { GLTFLoader } from 'GLTFLoader';
        import { FontLoader } from 'FontLoader';
        import { TextGeometry } from 'TextGeometry';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 0.65;
        camera.position.y = 0;
        camera.position.x = 0;
        camera.zoom = 800;

        const clock = new THREE.Clock();

        // Directional light
        const light = new THREE.DirectionalLight();
        light.intensity = 3;
        light.position.set(0, 0.1, 1);
        scene.add(light);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('scene-container').appendChild(renderer.domElement);

        const loader = new GLTFLoader();
        loader.load(
            'https://raw.githubusercontent.com/olivierlarose/creative-404/main/public/medias/shards.glb',
            function (gltf) {
                gltf.scene.traverse(function (child) {
                    if (child.isMesh) {
                        child.material = new THREE.MeshPhysicalMaterial({
                            transmission: 0.99, // Makes the material fully transparent
                            thickness: 0.275, // Thickness of the material
                            ior: 1.8, // Index of Refraction
                            transparent: true,
                            roughness: 0,
                            clearcoat: 1,
                            clearcoatRoughness: 0.1,
                            reflectivity: 1,
                            metalness: 0.5,
                            color: 0xffffff
                        });
                    }
                });

                scene.add(gltf.scene);
            },
            undefined,
            function (error) {
                console.error('An error happened:', error);
            }
        );

        // Load 3D text
        var fontLoader = new FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            const textGeo = new TextGeometry('404 Not Found', {
                font: font,
                size: 0.2,
                depth: 0.01,
                anchorX: "center",
                anchorY: "middle"
            });
            const textGeo2 = new TextGeometry('The link is broken', {
                font: font,
                size: 0.1,
                depth: 0.01,
                anchorX: "center",
                anchorY: "middle"
            });
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White color
            const textMesh = new THREE.Mesh(textGeo, textMaterial);
            textMesh.position.set(-0.95, -.05, -0.55);
            scene.add(textMesh);
            const textMaterial2 = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White color
            const textMesh2 = new THREE.Mesh(textGeo2, textMaterial2);
            textMesh2.position.set(-0.5, -.25, -0.65);
            scene.add(textMesh2);
        });

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime()

            // Find a child of the scene with further children
            let targetChild = null;
            scene.children.forEach(child => {
                if (child.children.length > 0) {
                    targetChild = child;
                }
            });

            // If a child with further children is found, animate its children
            if (targetChild) {
                const shards = targetChild.children;
                shards.forEach((child, index) => {
                    // make it go up and down
                    child.position.x = Math.sin(elapsedTime * 1.1 + index) * 0.01;
                    child.position.y = Math.sin(elapsedTime * 1.1 + index) * 0.01;
                    child.rotateX(Math.sin(elapsedTime * 0.001 + index) * 0.001);
                });
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>